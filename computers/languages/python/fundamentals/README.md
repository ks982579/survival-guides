# Python Fundamentals

## 

The [documentation](https://docs.python.org/3/) is the number one place to go for any questions. These notes are more like a cheatsheet for concepts already learned. 

Python is a dynamically typed, object-oriented, high-level programming language. Combined with its human readable syntax and interpreted nature, it's a great language to learn and use. 

The [reference manual](https://docs.python.org/3/reference/lexical_analysis.html) states that a Python program is read by a _parser_, which receives a stream of tokens generated by the _lexical analyzer_. 

Lines are ended by the __NEWLINE__ token. However, to make code more human readable, one can use the ```(\)``` backslash character to escape the token. Note that a line ending in a backslash __cannot__ carry a comment. 

Leading whitespace (spaces and tabs) at the beginning of a "logical line" is used to determine grouping of statements. The indentation levels generate __INDENT__ and __DEDENT__ tokens. 

Other tokens include: _identifiers_, _keywords_, _literals_, _operators_, and _delimiters_.

[@here](https://docs.python.org/3/reference/lexical_analysis.html#identifiers)

Identifiers can be thought of as variables in code. The following is a list of keywords:

|  |  |  |   |
| :----: | :----: | :----: |  :----: |
| False | True | None | and |
| as | assert | async | await |
| break | class | continue | def |
| del | elif | else | except |
| finally | for | from | global |
| if | import | in | is |
| lambda | nonlocal | not | or |
| pass | raise | return | try |
| while | with | yield |

Keywords such as _match_, _case_, and _ are __soft keywords__, which are keywords for the pattern matching statement. The keywords are recognized at the parser level, not when tokenizing. 

---
Strings are surrounded by either single or double quotes. They can also be enclosed in triple-quotes. The backslash (\\) can escape the quotes to give new meaning to characters. You may add a backslash in a single/double quote string write on a newline without causing error. This may be done in the triple-quoted strings as well. You can find a list of escape characters [here](https://docs.python.org/3/reference/lexical_analysis.html#literals).

Strings can also be prefixed by letters go give then different meanings. Byte literals are always prefixed with 'b' or 'B' and produce an instance of ```bytes``` type instead of ```string```. Strings prefixed with 'r' or 'R' to become _raw strings_, which ignores the escape character. Strings prefixed with 'u' or 'U' to become _unicode literals_, which are for unicode legacy literals. And you can combine some of the prefixes such as 'rb'. 

Multiple adjacent string or bytes literals (delimited by whitespace), and even using different quoting conventions, will be contatenated. This feature is defined at the syntactical level, but implemented at compile time. 
```python
print("Hello " 'World')
# Hello World
```

My favourte prefix is the 'f' or 'F' prefix for a _formatted string literal_. It may be combined with 'fr', but not with 'b' nor 'u'. Format string syntax can be found [here](https://docs.python.org/3/library/string.html#format-string-syntax).
```python
import decimal

name = "Sakura"
print(f'Her name is {name!r}.')
# Her name is 'Sakura'.
## !r is the same as repr(name)

width, precision = 10, 5
value = decimal.Decimal("12.3456789")
print(f"result: {value:{width}.{precision}}")
# result:     12.346
```
[@here](https://docs.python.org/3/reference/lexical_analysis.html#formatted-string-literals)

More examples in documentation. There are three types of numeric literals: integers, floating point, and imaginary. The documentation also provides a list of [operator](https://docs.python.org/3/reference/lexical_analysis.html#operators) and [delimiter](https://docs.python.org/3/reference/lexical_analysis.html#delimiters) tokens. 

---

We now move to [Data Models](https://docs.python.org/3/reference/datamodel.html#data-model). Every __object__ in Python has an _identity_, a _type_, and a _value_. 